// Package genapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by unknown module path version unknown version DO NOT EDIT.
package genapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	APIKeyHeaderScopes = "APIKeyHeader.Scopes"
)

// Defines values for LanguageFree.
const (
	En LanguageFree = "en"
)

// Defines values for Units.
const (
	Auto   Units = "auto"
	Ca     Units = "ca"
	Metric Units = "metric"
	Uk     Units = "uk"
	Us     Units = "us"
)

// FindPlacesModel defines model for FindPlacesModel.
type FindPlacesModel struct {
	// AdmArea1 first-level administrative area (a US state, for example)
	AdmArea1 *string `json:"adm_area1,omitempty"`

	// AdmArea2 second-level administrative area (a US county, for example)
	AdmArea2 *string `json:"adm_area2,omitempty"`

	// Country name of the country
	Country *string `json:"country,omitempty"`

	// Lat Latitude of the point, always in the format \<float><N/S>, for example ``23.5S``
	Lat *string `json:"lat,omitempty"`

	// Lon Longitude of the point, always in format \<float><E/W>, for example ``23.5W``
	Lon *string `json:"lon,omitempty"`

	// Name name of the place
	Name *string `json:"name,omitempty"`

	// PlaceId unique identifier of the place, which can be used in /point and /map endpoints
	PlaceId *string `json:"place_id,omitempty"`

	// Timezone Timezone of the point in tzinfo format.
	Timezone *string `json:"timezone,omitempty"`

	// Type The character of the place. May be one of the following values:
	//
	// * administrative areas (states, counties, districts...): ``administrative_area``
	// * country: ``country``
	// * a different political entity from a country (for example, a dependent teritory): ``political_entity``
	// * villages, towns and cities: ``settlement``
	// * air industry locations: ``airbase``, ``airfield``, ``heliport``, ``airport``, ``airport_terminal``
	// * places related to water: ``bay``, ``channel``, ``fjord``, ``lake``, ``pond``, ``falls``, ``gulf``,
	//     ``harbor``, ``reservoir``, ``sea``, ``dam``, ``cape``, ``island``, ``peninsula``
	// * places related to mountain areas: ``hill``, ``mountain``, ``peak``, ``valley``, ``volcano``, ``canyon``
	// * other places related to nature: ``park``, ``reserve``, ``resort``, ``desert``
	// * places based on postcodes: ``postcode``
	//
	Type *string `json:"type,omitempty"`
}

// GeneralRequestError defines model for GeneralRequestError.
type GeneralRequestError struct {
	Detail string `json:"detail"`
}

// HTTPValidationError defines model for HTTPValidationError.
type HTTPValidationError struct {
	Detail *[]ValidationError `json:"detail,omitempty"`
}

// LanguageFree An enumeration.
type LanguageFree string

// PointPointCurrentData defines model for Point_PointCurrentData.
type PointPointCurrentData struct {
	// CloudCover Percentage of sky covered by clouds.
	// Unit: \%
	CloudCover *float32 `json:"cloud_cover,omitempty"`

	// Icon String identifier of current weather icon, e.g. `light_rain`.
	Icon *string `json:"icon,omitempty"`

	// IconNum Numeric identifier of current weather icon. The following values can appear:
	//
	// * 1 - Not available
	// * 2 - Sunny
	// * 3 - Mostly sunny
	// * 4 - Partly sunny
	// * 5 - Mostly cloudy
	// * 6 - Cloudy
	// * 7 - Overcast
	// * 8 - Overcast with low clouds
	// * 9 - Fog
	// * 10 - Light rain
	// * 11 - Rain
	// * 12 - Possible rain
	// * 13 - Rain shower
	// * 14 - Thunderstorm
	// * 15 - Local thunderstorms
	// * 16 - Light snow
	// * 17 - Snow
	// * 18 - Possible snow
	// * 19 - Snow shower
	// * 20 - Rain and snow
	// * 21 - Possible rain and snow
	// * 22 - Rain and snow
	// * 23 - Freezing rain
	// * 24 - Possible freezing rain
	// * 25 - Hail
	// * 26 - Clear (night)
	// * 27 - Mostly clear (night)
	// * 28 - Partly clear (night)
	// * 29 - Mostly cloudy (night)
	// * 30 - Cloudy (night)
	// * 31 - Overcast with low clouds (night)
	// * 32 - Rain shower (night)
	// * 33 - Local thunderstorms (night)
	// * 34 - Snow shower (night)
	// * 35 - Rain and snow (night)
	// * 36 - Possible freezing rain (night)
	//
	// Unit: weather_ico0_36
	IconNum       *int                               `json:"icon_num,omitempty"`
	Precipitation PointPointCurrentPrecipitationData `json:"precipitation"`

	// Summary Short text summary of current weather, e.g. `Light rain`.
	Summary *string `json:"summary,omitempty"`

	// Temperature Current temperature 2 metres above ground.
	// Units: metric = °C, us = °F, uk = °C, ca = °C
	Temperature *float32                  `json:"temperature,omitempty"`
	Wind        PointPointCurrentWindData `json:"wind"`
}

// PointPointCurrentPrecipitationData defines model for Point_PointCurrentPrecipitationData.
type PointPointCurrentPrecipitationData struct {
	// Total Current amount of precipitation.
	// Units: metric = mm/h, us = inches per hour, uk = mm/h, ca = mm/h
	Total *float32 `json:"total,omitempty"`

	// Type Precipitation type, may be one of:
	//
	// * `none`, it there is no precipitation
	// * `rain`
	// * `snow`
	// * `rain_snow`
	// * `ice pellets`
	// * `frozen rain`
	//
	// Unit: prec_str
	Type *openapi_types.File `json:"type,omitempty"`
}

// PointPointCurrentWindData defines model for Point_PointCurrentWindData.
type PointPointCurrentWindData struct {
	// Angle Wind direction angle in degrees, 180° means wind from the south.
	// Unit: degrees
	Angle *float32 `json:"angle,omitempty"`

	// Dir Wind direction in `N`, `NNE`, `NE`, ..., `NNW` format.
	// Unit: 16dir
	Dir *string `json:"dir,omitempty"`

	// Speed Wind speed 10 metres above the ground.
	// Units: metric = m/s, us = mph, uk = mph, ca = km/h
	Speed *float32 `json:"speed,omitempty"`
}

// PointPointDaily defines model for Point_PointDaily.
type PointPointDaily struct {
	Data []PointPointDailyData `json:"data"`
}

// PointPointDailyAllDayCloudCoverData defines model for Point_PointDailyAllDayCloudCoverData.
type PointPointDailyAllDayCloudCoverData struct {
	// Total Percentage of sky covered by clouds. (allday avg)
	// Unit: \%
	Total *float32 `json:"total,omitempty"`
}

// PointPointDailyAllDayData defines model for Point_PointDailyAllDayData.
type PointPointDailyAllDayData struct {
	CloudCover PointPointDailyAllDayCloudCoverData `json:"cloud_cover"`

	// Icon Numeric identifier of the weather icon. The following values can appear:
	//
	// * 1 - Not available
	// * 2 - Sunny
	// * 3 - Mostly sunny
	// * 4 - Partly sunny
	// * 5 - Mostly cloudy
	// * 6 - Cloudy
	// * 7 - Overcast
	// * 8 - Overcast with low clouds
	// * 9 - Fog
	// * 10 - Light rain
	// * 11 - Rain
	// * 12 - Possible rain
	// * 13 - Rain shower
	// * 14 - Thunderstorm
	// * 15 - Local thunderstorms
	// * 16 - Light snow
	// * 17 - Snow
	// * 18 - Possible snow
	// * 19 - Snow shower
	// * 20 - Rain and snow
	// * 21 - Possible rain and snow
	// * 22 - Rain and snow
	// * 23 - Freezing rain
	// * 24 - Possible freezing rain
	// * 25 - Hail
	// * 26 - Clear (night)
	// * 27 - Mostly clear (night)
	// * 28 - Partly clear (night)
	// * 29 - Mostly cloudy (night)
	// * 30 - Cloudy (night)
	// * 31 - Overcast with low clouds (night)
	// * 32 - Rain shower (night)
	// * 33 - Local thunderstorms (night)
	// * 34 - Snow shower (night)
	// * 35 - Rain and snow (night)
	// * 36 - Possible freezing rain (night)
	//
	// Unit: icon
	Icon          *int                                   `json:"icon,omitempty"`
	Precipitation PointPointDailyAllDayPrecipitationData `json:"precipitation"`

	// Temperature Temperature 2 metres above ground. (allday avg)
	// Units: metric = °C, us = °F, uk = °C, ca = °C
	Temperature *float32 `json:"temperature,omitempty"`

	// TemperatureMax Units: metric = °C, us = °F, uk = °C, ca = °C
	TemperatureMax *float32 `json:"temperature_max,omitempty"`

	// TemperatureMin Units: metric = °C, us = °F, uk = °C, ca = °C
	TemperatureMin *float32 `json:"temperature_min,omitempty"`

	// Weather All day string identifier of the weather icon, e.g. `light_rain`.
	Weather *string                       `json:"weather,omitempty"`
	Wind    PointPointDailyAllDayWindData `json:"wind"`
}

// PointPointDailyAllDayPrecipitationData defines model for Point_PointDailyAllDayPrecipitationData.
type PointPointDailyAllDayPrecipitationData struct {
	// Total Total precipitation amount accumulated since last hour. (allday sum)
	// Units: metric = mm/h, us = inches per hour, uk = mm/h, ca = mm/h
	Total *float32 `json:"total,omitempty"`

	// Type Precipitation type, may be one of:
	//
	// * `none`, it there is no precipitation
	// * `rain`
	// * `snow`
	// * `rain_snow`
	// * `ice pellets`
	// * `frozen rain`
	//
	// Unit: precipitation type
	Type *openapi_types.File `json:"type,omitempty"`
}

// PointPointDailyAllDayWindData defines model for Point_PointDailyAllDayWindData.
type PointPointDailyAllDayWindData struct {
	// Angle All day wind direction angle in degrees, 180° means wind from the south.
	// Unit: degrees
	Angle *float32 `json:"angle,omitempty"`

	// Dir All day wind direction in `N`, `NNE`, `NE`, ..., `NNW` format.
	// Unit: 16dir
	Dir *openapi_types.File `json:"dir,omitempty"`

	// Speed Units: metric = m/s, us = mph, uk = mph, ca = km/h
	Speed *float32 `json:"speed,omitempty"`
}

// PointPointDailyData defines model for Point_PointDailyData.
type PointPointDailyData struct {
	Afternoon *interface{}              `json:"afternoon,omitempty"`
	AllDay    PointPointDailyAllDayData `json:"all_day"`

	// Day Datetime in YYYY-MM-DDTHH:MM:SS format.
	Day     *openapi_types.File `json:"day,omitempty"`
	Evening *interface{}        `json:"evening,omitempty"`

	// Icon Numeric identifier of the weather icon. The following values can appear:
	//
	// * 1 - Not available
	// * 2 - Sunny
	// * 3 - Mostly sunny
	// * 4 - Partly sunny
	// * 5 - Mostly cloudy
	// * 6 - Cloudy
	// * 7 - Overcast
	// * 8 - Overcast with low clouds
	// * 9 - Fog
	// * 10 - Light rain
	// * 11 - Rain
	// * 12 - Possible rain
	// * 13 - Rain shower
	// * 14 - Thunderstorm
	// * 15 - Local thunderstorms
	// * 16 - Light snow
	// * 17 - Snow
	// * 18 - Possible snow
	// * 19 - Snow shower
	// * 20 - Rain and snow
	// * 21 - Possible rain and snow
	// * 22 - Rain and snow
	// * 23 - Freezing rain
	// * 24 - Possible freezing rain
	// * 25 - Hail
	// * 26 - Clear (night)
	// * 27 - Mostly clear (night)
	// * 28 - Partly clear (night)
	// * 29 - Mostly cloudy (night)
	// * 30 - Cloudy (night)
	// * 31 - Overcast with low clouds (night)
	// * 32 - Rain shower (night)
	// * 33 - Local thunderstorms (night)
	// * 34 - Snow shower (night)
	// * 35 - Rain and snow (night)
	// * 36 - Possible freezing rain (night)
	//
	// Unit: icon
	Icon    *int         `json:"icon,omitempty"`
	Morning *interface{} `json:"morning,omitempty"`

	// Summary Short text summary of the weather, e.g. `Light rain`.
	Summary *string `json:"summary,omitempty"`

	// Weather All day string identifier of the weather icon, e.g. `light_rain`.
	Weather *string `json:"weather,omitempty"`
}

// PointPointData defines model for Point_PointData.
type PointPointData struct {
	Current *PointPointCurrentData `json:"current,omitempty"`
	Daily   *PointPointDaily       `json:"daily,omitempty"`

	// Elevation Elevation above sea level in metres (for units 'metric', 'uk', 'ca') or feet (for units 'us')
	Elevation int               `json:"elevation"`
	Hourly    *PointPointHourly `json:"hourly,omitempty"`

	// Lat Latitude of the point, always in the format <float><N/S>, for example ``23.5S``
	Lat string `json:"lat"`

	// Lon Longitude of the point, always in the format <float><E/W>, for example ``23.5W``
	Lon string `json:"lon"`

	// Timezone Name of the timezone in format like 'Europe/London'. Available only when the place is specified through place ID.
	Timezone *string `json:"timezone,omitempty"`

	// Units Unit system (metric, uk, ca or us)
	Units string `json:"units"`
}

// PointPointHourly defines model for Point_PointHourly.
type PointPointHourly struct {
	Data []PointPointHourlyData `json:"data"`
}

// PointPointHourlyCloudCoverData defines model for Point_PointHourlyCloudCoverData.
type PointPointHourlyCloudCoverData struct {
	// Total Unit: \%
	Total *float32 `json:"total,omitempty"`
}

// PointPointHourlyData defines model for Point_PointHourlyData.
type PointPointHourlyData struct {
	CloudCover PointPointHourlyCloudCoverData `json:"cloud_cover"`

	// Date Datetime in YYYY-MM-DDTHH:MM:SS format.
	Date *time.Time `json:"date,omitempty"`

	// Icon Numeric identifier of the weather icon. The following values can appear:
	//
	// * 1 - Not available
	// * 2 - Sunny
	// * 3 - Mostly sunny
	// * 4 - Partly sunny
	// * 5 - Mostly cloudy
	// * 6 - Cloudy
	// * 7 - Overcast
	// * 8 - Overcast with low clouds
	// * 9 - Fog
	// * 10 - Light rain
	// * 11 - Rain
	// * 12 - Possible rain
	// * 13 - Rain shower
	// * 14 - Thunderstorm
	// * 15 - Local thunderstorms
	// * 16 - Light snow
	// * 17 - Snow
	// * 18 - Possible snow
	// * 19 - Snow shower
	// * 20 - Rain and snow
	// * 21 - Possible rain and snow
	// * 22 - Rain and snow
	// * 23 - Freezing rain
	// * 24 - Possible freezing rain
	// * 25 - Hail
	// * 26 - Clear (night)
	// * 27 - Mostly clear (night)
	// * 28 - Partly clear (night)
	// * 29 - Mostly cloudy (night)
	// * 30 - Cloudy (night)
	// * 31 - Overcast with low clouds (night)
	// * 32 - Rain shower (night)
	// * 33 - Local thunderstorms (night)
	// * 34 - Snow shower (night)
	// * 35 - Rain and snow (night)
	// * 36 - Possible freezing rain (night)
	//
	// Unit: weather_ico0_36
	Icon          *int                              `json:"icon,omitempty"`
	Precipitation PointPointHourlyPrecipitationData `json:"precipitation"`

	// Summary Short text summary of the weather, e.g. `Light rain`.
	Summary *string `json:"summary,omitempty"`

	// Temperature Units: metric = °C, us = °F, uk = °C, ca = °C
	Temperature *float32 `json:"temperature,omitempty"`

	// Weather String identifier of the weather icon, e.g. `light_rain`.
	Weather *string                  `json:"weather,omitempty"`
	Wind    PointPointHourlyWindData `json:"wind"`
}

// PointPointHourlyPrecipitationData defines model for Point_PointHourlyPrecipitationData.
type PointPointHourlyPrecipitationData struct {
	// Total Total precipitation amount accumulated since last hour.
	// Units: metric = mm/h, us = inches per hour, uk = mm/h, ca = mm/h
	Total *float32 `json:"total,omitempty"`

	// Type Precipitation type, may be one of:
	//
	// * `none`, it there is no precipitation
	// * `rain`
	// * `snow`
	// * `rain_snow`
	// * `ice pellets`
	// * `frozen rain`
	//
	// Unit: precipitation type
	Type *openapi_types.File `json:"type,omitempty"`
}

// PointPointHourlyWindData defines model for Point_PointHourlyWindData.
type PointPointHourlyWindData struct {
	// Angle Wind direction angle in degrees, 180° means wind from the south.
	// Unit: degrees
	Angle *float32 `json:"angle,omitempty"`

	// Dir Wind direction in `N`, `NNE`, `NE`, ..., `NNW` format.
	// Unit: 16dir
	Dir *openapi_types.File `json:"dir,omitempty"`

	// Speed Units: metric = m/s, us = mph, uk = mph, ca = km/h
	Speed *float32 `json:"speed,omitempty"`
}

// Units An enumeration.
type Units string

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Loc  []ValidationError_Loc_Item `json:"loc"`
	Msg  string                     `json:"msg"`
	Type string                     `json:"type"`
}

// ValidationErrorLoc0 defines model for .
type ValidationErrorLoc0 = string

// ValidationErrorLoc1 defines model for .
type ValidationErrorLoc1 = int

// ValidationError_Loc_Item defines model for ValidationError.loc.Item.
type ValidationError_Loc_Item struct {
	union json.RawMessage
}

// FindPlacesFindPlacesGetParams defines parameters for FindPlacesFindPlacesGet.
type FindPlacesFindPlacesGetParams struct {
	// Text Place name or ZIP code
	Text string `form:"text" json:"text"`

	// Language The language of text summaries and place names (variable names are never translated). For the free tier,
	// only ``en`` (English) is available.
	Language *LanguageFree `form:"language,omitempty" json:"language,omitempty"`

	// Key Your unique API key. You can either specify it in this parameter, or set it in `X-API-Key` header.
	Key *string `form:"key,omitempty" json:"key,omitempty"`
}

// FindPlacesPrefixFindPlacesPrefixGetParams defines parameters for FindPlacesPrefixFindPlacesPrefixGet.
type FindPlacesPrefixFindPlacesPrefixGetParams struct {
	// Text Place name or ZIP code
	Text string `form:"text" json:"text"`

	// Language The language of text summaries and place names (variable names are never translated). For the free tier,
	// only ``en`` (English) is available.
	Language *LanguageFree `form:"language,omitempty" json:"language,omitempty"`

	// Key Your unique API key. You can either specify it in this parameter, or set it in `X-API-Key` header.
	Key *string `form:"key,omitempty" json:"key,omitempty"`
}

// NearestPlaceNearestPlaceGetParams defines parameters for NearestPlaceNearestPlaceGet.
type NearestPlaceNearestPlaceGetParams struct {
	// Lat Latitude in format 12N, 12.3N, 12.3, or 13S, 13.2S, -13.4
	Lat string `form:"lat" json:"lat"`

	// Lon Longitude in format 12E, 12.3E, 12.3, or 13W, 13.2W, -13.4
	Lon string `form:"lon" json:"lon"`

	// Language The language of text summaries and place names (variable names are never translated). For the free tier,
	// only ``en`` (English) is available.
	Language *LanguageFree `form:"language,omitempty" json:"language,omitempty"`

	// Key Your unique API key. You can either specify it in this parameter, or set it in `X-API-Key` header.
	Key *string `form:"key,omitempty" json:"key,omitempty"`
}

// PointPointGetParams defines parameters for PointPointGet.
type PointPointGetParams struct {
	// PlaceId Identifier of a place. To obtain the `place_id` for the location you want, please use endpoints `/find_places_prefix` (search by prefix) or `/find_places` (search by full name).
	PlaceId *string `form:"place_id,omitempty" json:"place_id,omitempty"`

	// Lat Latitude in format 12N, 12.3N, 12.3, or 13S, 13.2S, -13.4
	Lat *string `form:"lat,omitempty" json:"lat,omitempty"`

	// Lon Longitude in format 12E, 12.3E, 12.3, or 13W, 13.2W, -13.4
	Lon *string `form:"lon,omitempty" json:"lon,omitempty"`

	// Sections Sections to be included in the response. You can specify more section by separating the values with a comma. The available values are:
	//
	// * ``current``: Current weather situation
	// * ``daily``: Forecasts for each whole day
	// * ``hourly``: Forecasts with hourly resolution
	// * ``all``: All sections
	Sections *string `form:"sections,omitempty" json:"sections,omitempty"`

	// Timezone Timezone to be used for the date fields. If not specified, local timezone of the forecast location will be used.
	// The format is according to the tzinfo database, so values like `Europe/Prague` or `UTC` can be used.
	// Alternatively you may use the value ``auto`` in which case the local timezone of the location is used.
	// The full list of valid timezone strings can be found [here](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty"`

	// Language The language of text summaries and place names (variable names are never translated). For the free tier,
	// only ``en`` (English) is available.
	Language *LanguageFree `form:"language,omitempty" json:"language,omitempty"`

	// Units Unit system to be used. The available values are:
	//
	// * `auto`: Select the system automatically, based on the forecast location.
	// * `metric`: Metric (SI) units (`°C`, `mm/h`, `m/s`, `cm`, `km`, `hPa`).
	// * `us`: Imperial units (`°F`, `in/h`, `mph`, `in`, `mi`, `Hg`).
	// * `uk`: Same as ``metric``, except that visibility is in `miles` and wind speeds are in `mph`.
	// * `ca`: Same as ``metric``, except that wind speeds are in `km/h` and pressure is in `kPa`.
	Units *Units `form:"units,omitempty" json:"units,omitempty"`

	// Key Your unique API key. You can either specify it in this parameter, or set it in `X-API-Key` header.
	Key *string `form:"key,omitempty" json:"key,omitempty"`
}

// AsValidationErrorLoc0 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc0
func (t ValidationError_Loc_Item) AsValidationErrorLoc0() (ValidationErrorLoc0, error) {
	var body ValidationErrorLoc0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc0 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) FromValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc0 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsValidationErrorLoc1 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc1
func (t ValidationError_Loc_Item) AsValidationErrorLoc1() (ValidationErrorLoc1, error) {
	var body ValidationErrorLoc1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc1 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) FromValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc1 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ValidationError_Loc_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// FindPlacesFindPlacesGet request
	FindPlacesFindPlacesGet(ctx context.Context, params *FindPlacesFindPlacesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPlacesPrefixFindPlacesPrefixGet request
	FindPlacesPrefixFindPlacesPrefixGet(ctx context.Context, params *FindPlacesPrefixFindPlacesPrefixGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NearestPlaceNearestPlaceGet request
	NearestPlaceNearestPlaceGet(ctx context.Context, params *NearestPlaceNearestPlaceGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PointPointGet request
	PointPointGet(ctx context.Context, params *PointPointGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) FindPlacesFindPlacesGet(ctx context.Context, params *FindPlacesFindPlacesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPlacesFindPlacesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPlacesPrefixFindPlacesPrefixGet(ctx context.Context, params *FindPlacesPrefixFindPlacesPrefixGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPlacesPrefixFindPlacesPrefixGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NearestPlaceNearestPlaceGet(ctx context.Context, params *NearestPlaceNearestPlaceGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNearestPlaceNearestPlaceGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PointPointGet(ctx context.Context, params *PointPointGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPointPointGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewFindPlacesFindPlacesGetRequest generates requests for FindPlacesFindPlacesGet
func NewFindPlacesFindPlacesGetRequest(server string, params *FindPlacesFindPlacesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/find_places")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, params.Text); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindPlacesPrefixFindPlacesPrefixGetRequest generates requests for FindPlacesPrefixFindPlacesPrefixGet
func NewFindPlacesPrefixFindPlacesPrefixGetRequest(server string, params *FindPlacesPrefixFindPlacesPrefixGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/find_places_prefix")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, params.Text); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNearestPlaceNearestPlaceGetRequest generates requests for NearestPlaceNearestPlaceGet
func NewNearestPlaceNearestPlaceGetRequest(server string, params *NearestPlaceNearestPlaceGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nearest_place")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lat", runtime.ParamLocationQuery, params.Lat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lon", runtime.ParamLocationQuery, params.Lon); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPointPointGetRequest generates requests for PointPointGet
func NewPointPointGetRequest(server string, params *PointPointGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/point")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PlaceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "place_id", runtime.ParamLocationQuery, *params.PlaceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lat", runtime.ParamLocationQuery, *params.Lat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lon != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lon", runtime.ParamLocationQuery, *params.Lon); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sections != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sections", runtime.ParamLocationQuery, *params.Sections); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timezone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Units != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, *params.Units); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// FindPlacesFindPlacesGetWithResponse request
	FindPlacesFindPlacesGetWithResponse(ctx context.Context, params *FindPlacesFindPlacesGetParams, reqEditors ...RequestEditorFn) (*FindPlacesFindPlacesGetResponse, error)

	// FindPlacesPrefixFindPlacesPrefixGetWithResponse request
	FindPlacesPrefixFindPlacesPrefixGetWithResponse(ctx context.Context, params *FindPlacesPrefixFindPlacesPrefixGetParams, reqEditors ...RequestEditorFn) (*FindPlacesPrefixFindPlacesPrefixGetResponse, error)

	// NearestPlaceNearestPlaceGetWithResponse request
	NearestPlaceNearestPlaceGetWithResponse(ctx context.Context, params *NearestPlaceNearestPlaceGetParams, reqEditors ...RequestEditorFn) (*NearestPlaceNearestPlaceGetResponse, error)

	// PointPointGetWithResponse request
	PointPointGetWithResponse(ctx context.Context, params *PointPointGetParams, reqEditors ...RequestEditorFn) (*PointPointGetResponse, error)
}

type FindPlacesFindPlacesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FindPlacesModel
	JSON400      *GeneralRequestError
	JSON402      *GeneralRequestError
	JSON403      *GeneralRequestError
	JSON422      *HTTPValidationError
	JSON429      *GeneralRequestError
}

// Status returns HTTPResponse.Status
func (r FindPlacesFindPlacesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPlacesFindPlacesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPlacesPrefixFindPlacesPrefixGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FindPlacesModel
	JSON400      *GeneralRequestError
	JSON402      *GeneralRequestError
	JSON403      *GeneralRequestError
	JSON422      *HTTPValidationError
	JSON429      *GeneralRequestError
}

// Status returns HTTPResponse.Status
func (r FindPlacesPrefixFindPlacesPrefixGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPlacesPrefixFindPlacesPrefixGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NearestPlaceNearestPlaceGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindPlacesModel
	JSON400      *GeneralRequestError
	JSON402      *GeneralRequestError
	JSON403      *GeneralRequestError
	JSON422      *HTTPValidationError
	JSON429      *GeneralRequestError
}

// Status returns HTTPResponse.Status
func (r NearestPlaceNearestPlaceGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NearestPlaceNearestPlaceGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PointPointGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PointPointData
	JSON400      *GeneralRequestError
	JSON402      *GeneralRequestError
	JSON403      *GeneralRequestError
	JSON422      *HTTPValidationError
	JSON429      *GeneralRequestError
}

// Status returns HTTPResponse.Status
func (r PointPointGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PointPointGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// FindPlacesFindPlacesGetWithResponse request returning *FindPlacesFindPlacesGetResponse
func (c *ClientWithResponses) FindPlacesFindPlacesGetWithResponse(ctx context.Context, params *FindPlacesFindPlacesGetParams, reqEditors ...RequestEditorFn) (*FindPlacesFindPlacesGetResponse, error) {
	rsp, err := c.FindPlacesFindPlacesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPlacesFindPlacesGetResponse(rsp)
}

// FindPlacesPrefixFindPlacesPrefixGetWithResponse request returning *FindPlacesPrefixFindPlacesPrefixGetResponse
func (c *ClientWithResponses) FindPlacesPrefixFindPlacesPrefixGetWithResponse(ctx context.Context, params *FindPlacesPrefixFindPlacesPrefixGetParams, reqEditors ...RequestEditorFn) (*FindPlacesPrefixFindPlacesPrefixGetResponse, error) {
	rsp, err := c.FindPlacesPrefixFindPlacesPrefixGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPlacesPrefixFindPlacesPrefixGetResponse(rsp)
}

// NearestPlaceNearestPlaceGetWithResponse request returning *NearestPlaceNearestPlaceGetResponse
func (c *ClientWithResponses) NearestPlaceNearestPlaceGetWithResponse(ctx context.Context, params *NearestPlaceNearestPlaceGetParams, reqEditors ...RequestEditorFn) (*NearestPlaceNearestPlaceGetResponse, error) {
	rsp, err := c.NearestPlaceNearestPlaceGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNearestPlaceNearestPlaceGetResponse(rsp)
}

// PointPointGetWithResponse request returning *PointPointGetResponse
func (c *ClientWithResponses) PointPointGetWithResponse(ctx context.Context, params *PointPointGetParams, reqEditors ...RequestEditorFn) (*PointPointGetResponse, error) {
	rsp, err := c.PointPointGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePointPointGetResponse(rsp)
}

// ParseFindPlacesFindPlacesGetResponse parses an HTTP response from a FindPlacesFindPlacesGetWithResponse call
func ParseFindPlacesFindPlacesGetResponse(rsp *http.Response) (*FindPlacesFindPlacesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPlacesFindPlacesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FindPlacesModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseFindPlacesPrefixFindPlacesPrefixGetResponse parses an HTTP response from a FindPlacesPrefixFindPlacesPrefixGetWithResponse call
func ParseFindPlacesPrefixFindPlacesPrefixGetResponse(rsp *http.Response) (*FindPlacesPrefixFindPlacesPrefixGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPlacesPrefixFindPlacesPrefixGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FindPlacesModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseNearestPlaceNearestPlaceGetResponse parses an HTTP response from a NearestPlaceNearestPlaceGetWithResponse call
func ParseNearestPlaceNearestPlaceGetResponse(rsp *http.Response) (*NearestPlaceNearestPlaceGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NearestPlaceNearestPlaceGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindPlacesModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParsePointPointGetResponse parses an HTTP response from a PointPointGetWithResponse call
func ParsePointPointGetResponse(rsp *http.Response) (*PointPointGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PointPointGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PointPointData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest GeneralRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}
